process asanalyzer = {
    service = MessageLogger {
	untracked vstring destinations = {"cout"}
	untracked PSet cout = {untracked string threshold = "WARNING"}
    }
    
    source = PoolSource {
	untracked vstring fileNames = {
	    "/store/mc/2008/4/13/FastSim-Zmumu_10TeV-ceballos-1208103652/0000/38BBC429-620A-DD11-B28D-000423D9863C.root"
	}
    }
    untracked PSet maxEvents = {untracked int32 input = 10000}

    # alignment conditions
    include "Configuration/StandardSequences/data/FrontierConditions.cff"

    # needed for track refitting
    include "MagneticField/Engine/data/volumeBasedMagneticField.cfi"
    include "Geometry/CMSCommonData/data/cmsIdealGeometryXML.cfi"
    include "Geometry/CommonDetUnit/data/bareGlobalTrackingGeometry.cfi"
    include "Geometry/TrackerNumberingBuilder/data/trackerNumberingGeometry.cfi"
    include "Geometry/TrackerGeometryBuilder/data/trackerGeometry.cfi"
    include "Geometry/MuonNumbering/data/muonNumberingInitialization.cfi"
    include "Geometry/DTGeometry/data/dtGeometry.cfi"
    include "Geometry/CSCGeometry/data/cscGeometry.cfi"
    include "Geometry/RPCGeometry/data/rpcGeometry.cfi"
    include "TrackingTools/TrackRefitter/data/TracksToTrajectories.cff"
    include "RecoTracker/TransientTrackingRecHit/data/TransientTrackingRecHitBuilderWithoutRefit.cfi"

#     # Produces Trajectories exactly like standard track-fitting.
#     # Although this produces what most people mean when they think
#     # of "residuals", they hide misalignment information because the
#     # Kalman fitter updates the track to the first muon hit in each
#     # chamber, and subsequent hits have small residuals.  (The story
#     # is more complicated due to smoothing of the forward and
#     # backward propagations, but in general, these residuals will
#     # tell you only about the intrinsic resolution.)
# 
#     module TrackRefitter = TracksToTrajectories {
# 	InputTag Tracks = ALCARECOMuAlZMuMu:GlobalMuon
# 	PSet TrackTransformer = {
# 	    string Fitter = "KFFitterForRefitInsideOut"
# 	    string Smoother = "KFSmootherForRefitInsideOut"
# 	    string Propagator = "SmartPropagatorAnyOpposite"
# 	    string TrackerRecHitBuilder = "WithoutRefit"
# 	    string MuonRecHitBuilder = "MuonRecHitBuilder"
# 	    string RefitDirection = "insideOut"
# 	    bool RefitRPCHits = false
# 	}
#     }

    # Produces Trajectories by extrapolation from the tracker to the
    # muon system.  The residuals distributions will be much wider,
    # but in the limit of large statistics, this should tell you if
    # you have any misalignments.
    module TrackRefitter = TrackerToMuonPropagator {
	InputTag globalMuons = ALCARECOMuAlZMuMu:SelectedMuons
	InputTag globalMuonTracks = ALCARECOMuAlZMuMu:GlobalMuon
	string propagator = "SmartPropagatorAnyOpposite"
	
	bool refitTrackerTrack = false
# 	    PSet trackerTrackTransformer = {
# 		string Fitter = "KFFitterForRefitInsideOut"
# 		string Smoother = "KFSmootherForRefitInsideOut"
# 		string Propagator = "SmartPropagatorAnyOpposite"
# 		string TrackerRecHitBuilder = "WithoutRefit"
# 		string MuonRecHitBuilder = "MuonRecHitBuilder"
# 		string RefitDirection = "insideOut"
# 		bool RefitRPCHits = false
# 	    }
    }

    # histogram file
    service = TFileService {string fileName = "histograms.root"}
    
    # alignment monitors wrapped up in an analyzer
    module AlignmentMonitorAsAnalyzer = AlignmentMonitorAsAnalyzer {
	include "Alignment/CommonAlignmentAlgorithm/data/AlignmentParameterStore.cfi"

	InputTag tjTkAssociationMapTag = TrackRefitter # source of Trajectories

	# select two packages for monitoring muon residuals
	untracked vstring monitors = {"AlignmentMonitorMuonResiduals", "AlignmentMonitorMuonHIP"}
	
	# parameters for AlignmentMonitorMuonResiduals
	# (new package which contains more summary information)
 	untracked PSet AlignmentMonitorMuonResiduals = {
	    uint32 xresid_bins = 200  double xresid_low = -5  double xresid_high = 5
	    uint32 xmean_bins = 400   double xmean_low = -1   double xmean_high = 1 
	    uint32 xstdev_bins = 300  double xstdev_low = 0   double xstdev_high = 3
	    uint32 yresid_bins = 200  double yresid_low = -5  double yresid_high = 5
	    uint32 ymean_bins = 400   double ymean_low = -1   double ymean_high = 1
	    uint32 ystdev_bins = 300  double ystdev_low = 0   double ystdev_high = 3
 	}
	
	# parameters for AlignmentMonitorMuonHIP
	# (old package which simply has one histogram per chamber)
	untracked PSet AlignmentMonitorMuonHIP = {
	    PSet params = {
		uint32 iterations = 11
		double iterations_low = -0.5
		double iterations_high = 10.5
		uint32 bins = 250
		double xresid_low = -5.
		double xresid_high = 5.
		double xresidwide_low = -5.
		double xresidwide_high = 5.
		double yresid_low = -5.
		double yresid_high = 5.
		double xDT_low = -300.
		double xDT_high = 300.
		double yDT_low = -300.
		double yDT_high = 300.
		double xCSC_low = -300.
		double xCSC_high = 300.
		double yCSC_low = -300.
		double yCSC_high = 300.
		double xpull_low = -15.
		double xpull_high = 15.
		double ypull_low = -15.
		double ypull_high = 15.
	    }
	    
	    PSet book = {
		string mode = "chamber"
		bool nhits_vsiter = false
		bool conv_x = false
		bool conv_y = false
		bool conv_z = false
		bool conv_phix = false
		bool conv_phiy = false
		bool conv_phiz = false
		bool xresid = true
		bool xresidwide = true
		bool yresid = true
		bool wxresid = true
		bool wxresidwide = true
		bool wyresid = true
		bool wxresid_vsx = false
		bool wxresid_vsy = false
		bool wyresid_vsx = false
		bool wyresid_vsy = false
		bool xpull = true
		bool ypull = true
		bool before = false
		bool after = false
	    }
	    
	    bool createPythonGeometry = false
	}
    }

    # first produce the Trajectories, then fill the histograms
    path p = {TrackRefitter, AlignmentMonitorAsAnalyzer}
}
